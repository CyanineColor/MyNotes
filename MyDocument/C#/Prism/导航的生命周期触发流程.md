## 一、导航离开时的生命周期触发流程

当执行`RequestNavigate("MainRegion", "NewView")`离开当前视图时，Prism按以下顺序触发：

### 1. **INavigationAware接口回调**（若ViewModel实现该接口）

csharp

复制

```csharp
public class CurrentViewModel : INavigationAware
{
    // 1. 先判断是否可以复用当前实例（全局单例情况）
    public bool IsNavigationTarget(NavigationContext navigationContext)
    {
        return false; // 返回false表示不重用，允许被移除
    }

    // 2. 离开前回调（清理资源的关键时机）
    public void OnNavigatedFrom(NavigationContext navigationContext)
    {
        // ★ 必须在此处解除事件订阅、释放非托管资源
        this.eventAggregator.GetEvent<SomeEvent>().Unsubscribe(OnSomeEvent);
        this.timer?.Stop(); // 停止定时器
        this.cancellationTokenSource?.Cancel(); // 取消异步任务
    }

    // 3. 导航到新视图时触发（与当前离开无关）
    public void OnNavigatedTo(NavigationContext navigationContext) { }
}
```

**调用顺序**：`IsNavigationTarget` → `OnNavigatedFrom` → 新视图创建 → 新视图`OnNavigatedTo`

---

## 二、View/ViewModel的复用与分离策略

### 1. **复用判断机制**

Prism通过`IsNavigationTarget`返回值决定**是否保留**当前视图实例：

- **返回`true`**：框架**保留**视图/ViewModel在内存中，下次导航回该视图时复用（不调用构造函数）
    
- **返回`false`**：框架**移除**视图/ViewModel，允许被GC回收
    

### 2. **视图从区域中移除**

当`IsNavigationTarget`返回`false`时，Prism自动执行：

csharp

复制

```csharp
// 框架内部伪代码
var oldView = region.ActiveViews.FirstOrDefault();
if (oldView != null && !viewModel.IsNavigationTarget(...))
{
    region.Remove(oldView); // 从视觉树移除
    // 此时View失去引用，ViewModel的DataContext绑定解除
}
```

---

## 三、内存回收核心机制与泄漏根源

### 1. **Prism的内存管理边界**

Prism**不直接管理内存回收**，它仅负责：

- ✅ 从`Region`中移除视图引用
    
- ✅ 解除`DataContext`绑定
    
- ✅ 触发`OnNavigatedFrom`通知
    

**真正的GC回收依赖**：WPF的依赖属性系统 + .NET垃圾回收器

### 2. **内存泄漏的四大元凶**

即使视图被移除，以下情况会**阻止GC回收**：

表格

复制

|泄漏原因|示例代码|解决方案|
|:--|:--|:--|
|**事件未退订**|`eventAggregator.GetEvent<XXX>().Subscribe(Handler)`|在`OnNavigatedFrom`中调用`Unsubscribe`|
|**静态引用**|`static List<WeakReference> _cache = new();`|使用`WeakReference`或避免静态缓存ViewModel|
|**定时器未停止**|`new Timer(TimerCallback, null, 0, 1000)`|停止定时器并置`null`|
|**命令绑定未清理**|`DelegateCommand`持有外部引用|确保命令生命周期不超长|

---

## 四、强制回收的主动清理策略

### 1. **主动移除视图并释放资源**

在`OnNavigatedFrom`中实现`IDisposable`模式：

csharp

复制

```csharp
public class CurrentViewModel : INavigationAware, IDisposable
{
    private CompositeDisposable _disposables = new(); // Rx.NET的便捷类
    
    public CurrentViewModel(IEventAggregator ea)
    {
        // 使用 Dispose 模式订阅事件
        ea.GetEvent<SomeEvent>()
          .Subscribe(OnSomeEvent)
          .DisposeWith(_disposables); // 加入待清理集合
    }

    public void OnNavigatedFrom(NavigationContext context)
    {
        Dispose(); // 导航离开时主动释放
    }

    public void Dispose()
    {
        _disposables?.Dispose(); // 一次性取消所有订阅
        _disposables = null;
        GC.SuppressFinalize(this); // 通知GC无需调用析构函数
    }
}
```

### 2. **在View层主动断开Binding**

csharp

复制

```csharp
public partial class CurrentView : UserControl, IDisposable
{
    public CurrentView()
    {
        InitializeComponent();
        this.Unloaded += (s, e) => Dispose(); // 视图卸载时触发
    }

    public void Dispose()
    {
        // 断开所有数据绑定，防止Binding泄漏
        this.DataContext = null; 
        // 清理图像、大集合等资源
        this.imageControl.Source = null; 
        this.listBox.ItemsSource = null;
    }
}
```

### 3. **配置Region的视图缓存策略**

通过`RegionMemberLifetimeAttribute`控制视图生命周期：

csharp

复制

```csharp
[RegionMemberLifetime(KeepAlive = false)] // 导航离开即销毁
public class CurrentViewModel : INavigationAware
{
    // 此标记等同于 IsNavigationTarget 始终返回 false
}
```

---

## 五、内存回收验证与调试

### 1. **验证视图是否被回收**

csharp

复制

```csharp
// 在ViewModel析构函数中打印日志
~CurrentViewModel()
{
    Debug.WriteLine("✅ ViewModel被GC回收");
}

// 在导航后强制GC
regionManager.RequestNavigate("MainRegion", "NewView");
GC.Collect();
GC.WaitForPendingFinalizers();
// 观察输出窗口是否有析构日志
```

### 2. **使用内存分析工具**

- **.NET Memory Profiler**：捕获快照，检查`Region`对象是否还持有`View`引用
    
- **Visual Studio诊断工具**：查看堆中`ViewModel`实例数量
    

---

## 六、最佳实践总结

1. **始终实现`INavigationAware.OnNavigatedFrom`**：在此方法中清理所有外部订阅、定时器、异步任务
    
2. **优先使用弱引用事件**：Prism的`IEventAggregator`本身是弱引用，但**自定义事件的委托必须是弱引用**
    
3. **避免ViewModel持有UI控件引用**：不要保存`Button`、`TextBox`等控件实例字段
    
4. **瞬态ViewModel + 返回`false`**：确保每次导航创建新实例，离开后立即释放
    
5. **大资源使用`WeakReference`**：如缓存图片、大数据集合
    
6. **在模块级别控制单例**：服务类用`RegisterSingleton`，ViewModel默认用瞬态
    

通过以上机制，Prism能确保导航离开时View/ViewModel被**逻辑移除**，但**物理内存回收**仍需开发者遵循WPF内存管理规范，主动切断所有外部引用。