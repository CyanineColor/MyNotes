C# 在异步编程领域不断演进，尤其是在 C# 8.0 及后续版本中，引入了多项新语法和技术，包括异步 `foreach`（`await foreach`）、异步 `Dispose`（`await using`）、异步一次性初始化、异步局部函数、异步迭代器中的异常处理、异步 LINQ 扩展、异步 CancellationToken 集成以及异步模式匹配。这些特性显著增强了异步编程的表达力、性能和灵活性。本文将逐一详细介绍这些新特性，包括其背景、语法细节、代码示例、使用场景、关键益处以及注意事项，并特别为异步模式匹配提供传统模式匹配的背景介绍。

  

## 1. 异步 foreach（IAsyncEnumerable 和 await foreach）

### 详细介绍

异步 `foreach`是 C# 8.0 引入的核心特性，用于处理异步流（`IAsyncEnumerable<T>`）。传统同步`foreach`用于迭代`IEnumerable<T>`集合，而在异步场景（如从数据库或网络逐个获取数据），开发者常需手动处理任务循环。异步流通过`IAsyncEnumerable<T>`和`await foreach`解决此问题，允许生产者异步生成元素，消费者逐个处理，而无需加载整个数据集。这基于 Task-based Asynchronous Pattern (TAP) 的扩展，支持在异步方法中使用`yield return`生成流式数据。核心接口包括`IAsyncEnumerable<T>`（异步可枚举集合）和`IAsyncEnumerator<T>`（异步枚举器），其`MoveNextAsync`方法返回`ValueTask<bool>` 以优化性能。异步流特别适合内存敏感或实时数据场景，因其支持惰性加载和流式处理。

异步流可与 `CancellationToken` 集成支持取消操作，或与第三方异步 LINQ 库结合进行查询操作。相比同步 `foreach`，异步版本允许在迭代中插入 `await`，如等待 I/O 操作，而不阻塞线程。

### 示例代码

以下示例展示生成和消费异步流，模拟逐个读取网络数据：

```
using System;
```

**运行结果**：每隔 1 秒打印一个数字，避免一次性加载所有数据。

### 应用场景

- 实时数据处理：如 WebSocket 消息、传感器数据或日志流。
    
- 大数据集分页：异步查询数据库（如 EF Core），逐个处理记录。
    
- 文件或网络流：异步逐行读取大文件或 API 响应流。
    
- 协程式编程：如游戏中的动画序列或 UI 更新。
    

### 关键益处

- **内存效率**
    
    惰性加载，适合大数据流，避免内存溢出。
    
- **代码简洁**
    
    读取类似同步代码，增强可读性。
    
- **性能优化**
    
    `ValueTask` 减少分配，支持高吞吐。
    
- **错误处理**
    
    自然支持异常传播和取消。
    

### 注意事项

- 需要 C# 8.0 及 .NET Core 3.0 或更高版本。
    
- 确保生产者与消费者异步协调，避免阻塞或资源泄漏。
    
- 在高并发场景中，监控线程池使用，避免线程饥饿。
    
- 对于无限流，添加超时或取消机制。
    

  

---

##   

## 2. 异步 Dispose（IAsyncDisposable 和 await using）

### 详细介绍

异步 `Dispose`是 C# 8.0 引入的特性，用于异步资源管理。传统`IDisposable`和`using`语句适用于同步释放资源（如文件句柄），但在异步场景中，释放可能涉及等待（如关闭网络连接），同步`Dispose`会阻塞线程。`IAsyncDisposable`接口通过`DisposeAsync`方法（返回`ValueTask`）支持异步清理，`await using`语法确保在作用域结束时异步调用`DisposeAsync`，类似同步`using` 但非阻塞。

此特性常与异步流结合使用，因为异步资源（如数据库上下文）可能产生流式数据。`IAsyncDisposable` 可与 `IDisposable` 共存，支持同步和异步场景。C# 10.0 的 `AsyncMethodBuilder` 属性进一步优化了异步方法，但核心异步 dispose 机制始于 C# 8.0。

### 示例代码

以下示例展示自定义异步资源类及其使用：

```
using System;
```

### 应用场景

- **数据库操作**
    
    异步关闭 EF Core `DbContext`，确保事务或连接释放。
    
- **网络资源**
    
    关闭 HTTP 客户端、WebSocket 或 gRPC 流。
    
- **文件处理**
    
    异步刷新并关闭大文件流。
    
- **自定义资源**
    
    如异步日志记录器或消息队列客户端。
    

### 关键益处

- **非阻塞释放**
    
    避免线程阻塞，提高响应性。
    
- **资源安全**
    
    自动异步清理，减少泄漏风险。
    
- **性能提升**
    
    `ValueTask` 降低 GC 压力。
    
- **与异步流集成**
    
    处理流式资源的清理。
    

### 注意事项

- 方法必须标记为 `async` 以使用 `await using`。
    
- 使用 `try-catch` 处理 `DisposeAsync` 中的异常。
    
- 优先异步释放以避免阻塞。
    
- 确保目标框架支持（.NET Core 3.0+）。
    

  

---

##   

## 3. 异步一次性初始化（AsyncLazy 和 ValueTask）

### 详细介绍

异步一次性初始化通过 `ValueTask<T>` 和自定义模式（如 `AsyncLazy<T>`）实现，类似于同步的 `Lazy<T>`，但适用于异步场景。`ValueTask<T>` 是 C# 7.0 引入的轻量级异步类型，减少 `Task<T>` 的对象分配，适合短期或同步完成的异步操作。`AsyncLazy<T>` 确保初始化只异步执行一次，后续访问直接返回缓存结果，支持并发安全。

此模式在 C# 8.0 后更常见，因其与异步流和 dispose 集成良好。例如，异步初始化数据库连接，首次连接异步完成，后续直接复用。

### 示例代码

自定义 `AsyncLazy<T>` 类：

```
using System;
```

### 应用场景

- **资源初始化**
    
    异步加载配置文件、数据库连接或 API 客户端。
    
- **缓存机制**
    
    缓存昂贵异步操作的结果。
    
- **单例模式**
    
    异步懒加载单例。
    
- **高性能服务**
    
    如 Web API 中异步初始化共享资源。
    

### 关键益处

- **性能优化**
    
    `ValueTask` 减少 GC 压力。
    
- **线程安全**
    
    支持并发访问，只初始化一次。
    
- **简洁性**
    
    封装异步延迟逻辑。
    

### 注意事项

- `ValueTask<T> 不可多次await，需重新创建。`
- 确保线程安全，高并发下考虑 `LazyInitializer`。
    
- 处理初始化失败的异常传播。
    

##   

##   

---

##   

## 4. 异步局部函数（Local Functions）

### 详细介绍

局部函数是 C# 7.0 引入的特性，在异步编程中支持 `async` 修饰符，允许在方法内部定义小型异步逻辑块。这提高了代码组织性，避免全局方法污染。异步局部函数可捕获外部变量（闭包），返回 `Task` 或 `ValueTask`，并在 C# 8.0 后与异步流集成。

与 lambda 不同，局部函数支持 `yield return` 生成异步流，且不分配委托，性能更优。它们在复杂异步方法中分解逻辑，提高可读性。

### 示例代码  

```
using System;
```

### 应用场景

- **逻辑分解**
    
    将复杂异步方法分解为局部函数。
    
- **测试调试**
    
    隔离异步逻辑，便于单元测试。
    
- **闭包使用**
    
    访问循环变量或状态。
    

### 关键益处

- **模块化**
    
    提高代码可读性和复用性。
    
- **性能**
    
    无委托分配开销。
    
- **灵活性**
    
    支持 `async` 和 `yield`。
    

### 注意事项

- 避免过度闭包导致内存泄漏。
    
- 局部函数不可重载，但可嵌套。
    

##   

##   

---

##   

## 5. 异步迭代器中的异常处理

### 详细介绍

C# 8.0 优化了异步迭代器的异常处理。在异步流中，生产者（`IAsyncEnumerable<T>`）抛出的异常会传播到消费者（`await foreach`），通过标准 `try-catch` 捕获。异常可能在 `yield return` 前后或 `MoveNextAsync` 中发生，消费者可统一处理。

此机制类似于同步 `foreach`，但支持异步上下文，确保异常传播不中断异步执行。

### 示例代码

```
using System;
```

### 应用场景

- **流式数据**
    
    捕获网络中断或解析错误。
    
- **数据库查询**
    
    处理连接失败或超时。
    

### 关键益处

- **一致性**
    
    与同步异常处理类似。
    
- **健壮性**
    
    自动传播异常。
    

### 注意事项

- 在消费者端捕获异常，生产者可抛出通知。
    
- 结合取消处理 `OperationCanceledException`。
    

##   

##   

---

##   

## 6. 异步 LINQ（第三方库支持）

### 详细介绍

C# 核心未提供异步 LINQ，但第三方库（如 `System.Linq.Async` 或 `System.Interactive.Async`）为 `IAsyncEnumerable<T>` 提供扩展方法，如 `WhereAsync`、`SelectAsync`。这些方法支持在谓词或投影中插入 `await`，适合异步过滤或转换流式数据。

异步 LINQ 保留了 LINQ 的声明式风格，但适配异步场景，增强了表达力。

### 示例代码

需安装 NuGet 包 `System.Linq.Async`：

```
using System;
```

### 应用场景

- **异步数据管道**
    
    过滤或转换实时流。
    
- **API 响应**
    
    异步处理 JSON 流。
    

### 关键益处

- **表达力**
    
    LINQ 风格的异步查询。
    
- **扩展性**
    
    支持链式操作。
    

### 注意事项

- 确保库版本兼容。
    
- 异步谓词可能增加性能开销。
    

##   

##   

---

##   

## 7. 异步 CancellationToken 集成

### 详细介绍

`CancellationToken` 是 C# 异步编程的取消机制，在 C# 8.0 后与异步流和 dispose 更好集成。通过 `WithCancellation`，可以将 token 传递到异步枚举器，支持中途停止。`[EnumeratorCancellation]` 属性允许生产者方法签名注入 token。

此机制支持响应外部信号（如用户取消或超时），提高资源效率。

### 示例代码

```
using System;
```

### 应用场景

- **超时操作**
    
    取消长运行流。
    
- **用户交互**
    
    响应取消按钮。
    

### 关键益处

- **精细控制**
    
    响应外部信号。
    
- **资源节省**
    
    及早停止操作。
    

### 注意事项

- 处理 `OperationCanceledException`。
    
- 默认 token 避免签名变化。
    

##   

---

##   

## 8. 异步模式匹配（C# 9.0 及以上）

### 传统模式匹配

模式匹配是 C# 7.0 引入的功能，通过 `is` 和 `switch` 语句/表达式简化类型检查和条件逻辑。传统模式匹配主要用于同步场景，处理类型、值或属性。例如：

```
object obj = "Hello";
```

传统模式匹配支持：

- **类型模式**
    
    检查对象类型并转换（如 `is string`）。
    
- **常量模式**
    
    匹配特定值。
    
- **属性模式**
    
    检查对象属性。
    
- **递归模式**
    
    嵌套检查（如 C# 8.0 的属性模式）。
    

这些功能在同步代码中简化了分支逻辑，但对于异步场景（如处理 `Task<T>`），需要手动 `await`，增加复杂性。

###   

### 异步模式匹配（C# 9.0 及以上）

C# 9.0 增强了模式匹配，与异步方法结合，允许在 `switch` 表达式或 `is` 语句中处理异步结果（如 `Task<T>`）。这通过直接 `await` 模式匹配的结果简化了异步逻辑。异步模式匹配支持类型模式、关系模式（如 `>`, `<`）和逻辑模式（如 `and`, `or`），与同步模式匹配一致，但适配异步上下文。

异步模式匹配的关键在于处理 `Task<T>` 或 `ValueTask<T>` 类型，自动解包异步结果，减少 boilerplate 代码。例如，匹配 `Task<string>` 并直接 `await` 其值。

### 示例代码

```
using System;
```

### 应用场景

- **异步结果处理**
    
    匹配不同类型的异步结果（如 API 响应）。
    
- **条件分支**
    
    异步逻辑中的类型或值分支。
    
- **错误处理**
    
    结合模式匹配检查异常或空值。
    

### 关键益处

- **简洁性**
    
    减少手动 `await` 和类型检查。
    
- **类型安全**
    
    编译时验证模式。
    
- **表达力**
    
    结合逻辑和关系模式。
    

### 注意事项

- 需要 C# 9.0 及 .NET 5.0 或更高版本。
    
- 处理 `null` 和异常情况。
    
- 避免复杂嵌套模式影响可读性。
    

##   

##   

---

##   

## 总结

C# 8.0 及后续版本的异步编程新特性极大提升了开发者的生产力，包括：

- **异步 foreach 和 Dispose：核心特性，支持流式数据和资源管理。**
- **异步一次性初始化：通过 ValueTask 优化性能。**
- **异步局部函数：提高代码组织性。**
- **异常处理和 CancellationToken 集成：增强健壮性。**
- **异步 LINQ 和 模式匹配：提供灵活的异步逻辑表达。**

这些特性适用于现代应用，如云服务、实时系统和大数据处理。开发者应关注版本兼容性、资源管理和性能优化，以充分发挥这些特性的优势。

文章出处：[盘点 C#、.NET中的一些新的异步语法和技术](https://mp.weixin.qq.com/s/padm-3doSLlNx7gWNEH36A)