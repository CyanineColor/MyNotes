在C#中解决集合线程安全问题的主要方式如下：

---

### 1. ‌**使用并发集合类（System.Collections.Concurrent）**‌

C#提供了线程安全的并发集合类，内部采用分区锁、CAS等机制优化并发性能，无需显式加锁：

- ‌**ConcurrentDictionary**‌：线程安全的字典，支持原子操作的增删改查

```C#

`var dict = new ConcurrentDictionary<string, int>(); dict.TryAdd("key", 1);  // 线程安全的添加操作`

```
- ‌**ConcurrentQueue/ConcurrentStack**‌：线程安全的队列/栈，支持生产者-消费者场景26
- ‌**ConcurrentBag**‌：无序集合，适合频繁添加/删除操作613
- ‌**BlockingCollection**‌：带阻塞功能的集合，支持最大容量限制和消费等待1314

---

### 2. ‌**显式加锁机制（lock/Monitor）**‌

通过`lock`关键字或`Monitor`类手动控制同步访问：


```C#
`private readonly object _lockObj = new object(); List<int> unsafeList = new List<int>();  lock (_lockObj) {     unsafeList.Add(item);  // 受锁保护的临界区 }`
```

- 适用于需要操作非线程安全集合（如List、Dictionary）的场景37

---

### 3. ‌**同步原语（Mutex/Semaphore等）**‌

- ‌**Mutex**‌：跨进程的互斥锁，适合复杂同步场景11
- ‌**Semaphore/SemaphoreSlim**‌：限制并发访问资源的线程数量1112

```C#

`using SemaphoreSlim semaphore = new SemaphoreSlim(2, 2); await semaphore.WaitAsync(); try { /* 临界区 */ } finally { semaphore.Release(); }`
```

---

### 4. ‌**读写锁（ReaderWriterLockSlim）**‌

针对读多写少的场景，允许多线程并发读取，独占写入：


```C#
`private ReaderWriterLockSlim _rwLock = new ReaderWriterLockSlim(); _rwLock.EnterReadLock(); try { /* 读取操作 */ } finally { _rwLock.ExitReadLock(); }`
```

- 相比普通锁能显著提升读取性能12

---

### 5. ‌**数据分区处理**‌

将集合数据分割为多个独立区块，每个线程处理独立分区：


```C#
`List<int>[] partitions = PartitionData(sourceList, 4);  // 分为4个区 Parallel.ForEach(partitions, partition => {     foreach (var item in partition) { /* 线程安全操作 */ } });`
```

- 通过减少共享数据竞争提升安全性8

---

### 6. ‌**UI线程安全访问（Control.Invoke）**‌

在WinForms/WPF中操作UI控件时强制切换到主线程：


```C#
`if (textBox.InvokeRequired) {     textBox.Invoke(() => textBox.Text = "更新内容"); }`
```

- 避免跨线程访问UI引发的异常5

---

#### ‌**选择建议**‌

- 优先使用`Concurrent`系列集合简化开发29
- 对现有非线程安全集合操作时，采用`lock`或同步原语38
- 高并发读场景选择读写锁，生产者-消费者场景用`BlockingCollection`